'''
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Author:B.Ajay
Licence:MIT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
'''
import matplotlib.pyplot as plt
import numpy as np
import math as m
#First general construct for linear approximation
'''Matrix inputs'''
'''
A=np.array([[9,-3,1],[4,-2,1],[0,0,1],[1,1,1]])
y=np.array([[9],[6],[2],[1]])
A_=A.T
prod1=np.linalg.inv(A_.dot(A))
prod2=A_.dot(y)
x0=prod1.dot(prod2)
E=np.linalg.norm(A.dot(x0)-y)**2
#print(x0)
print("Function is y={}t+{}".format(x0[0],x0[1]))
print("Error function E value: ",int(E))
'''
#Function to compute 1st orderApproximation
def least_square_approximator(a):
    A=np.array([[i[0],1]for i in a])
    y=np.array([[i[-1]]for i in a])
    A_=A.T
    prod1=np.linalg.inv(A_.dot(A))
    prod2=A_.dot(y)
    x0=prod1.dot(prod2)
    E=np.linalg.norm(A.dot(x0)-y)**2
    return x0,E
#Function to compute 2nd orderApproximation
def least_square_approximator2(a):
    A=np.array([[i[0]**2,i[0],1]for i in a])
    y=np.array([[i[-1]]for i in a])
    A_=A.T
    prod1=np.linalg.inv(A_.dot(A))
    prod2=A_.dot(y)
    x0=prod1.dot(prod2)
    E=np.linalg.norm(A.dot(x0)-y)**2
    return x0,E
#Function to compute 3rd orderApproximation
def least_square_approximator3(a):
    A=np.array([[i[0]**3,i[0]**2,i[0],1]for i in a])
    y=np.array([[i[-1]]for i in a])
    A_=A.T
    prod1=np.linalg.inv(A_.dot(A))
    prod2=A_.dot(y)
    x0=prod1.dot(prod2)
    E=np.linalg.norm(A.dot(x0)-y)**2
    return x0,E

def main():
    a=eval(input("Enter your pairs in (input,output) order include braces"))#input by user
    print("Linear or Firstorder Approximation")
    print("Function is y={}t+{}".format(least_square_approximator(a)[0][0],least_square_approximator(a)[0][1]))
    x=np.arange(-10,10,1)#for plotting the data points 
    y=least_square_approximator(a)[0][0]*x+least_square_approximator(a)[0][1]
    plt.plot(x,y)
    plt.title("First Order Approximation")
    plt.xlabel("Values")
    plt.ylabel("Function y={}t+{}".format(least_square_approximator(a)[0][0],least_square_approximator(a)[0][1]))
    for i in a:
        plt.scatter(i[0],i[1],s=50)#Highlighting the input points
    plt.show()
    print("Error function E value: ",least_square_approximator(a)[-1])
    print("-"*100)
    print("Second order Approximation")
    print("Function is y={}t^2+{}t+{}".format(least_square_approximator2(a)[0][0],least_square_approximator2(a)[0][1],least_square_approximator2(a)[0][-1]))
    print("Error function E value : ",least_square_approximator2(a)[-1])
    print("-"*100)
    x=np.arange(-10,10,1)
    y=least_square_approximator2(a)[0][0]*x**2+least_square_approximator2(a)[0][1]*x+least_square_approximator2(a)[0][-1]
    plt.plot(x,y)
    plt.title("Second Order Approximation")
    plt.xlabel("Values")
    plt.ylabel("Function y={}t^2+{}t+{}".format(least_square_approximator2(a)[0][0],least_square_approximator2(a)[0][1],least_square_approximator2(a)[0][-1]))
    for i in a:
        plt.scatter(i[0],i[1],s=50)
    plt.show()
    print("Third order Approximation")
    print("Function is y={}t^3+{}t^2+{}t+{}".format(least_square_approximator3(a)[0][0],least_square_approximator3(a)[0][1],least_square_approximator3(a)[0][2],least_square_approximator3(a)[0][-1]))
    print("Error function E value : ",least_square_approximator3(a)[-1])
    #x=[1,2,3]
    x=np.arange(-10,10,1)
    y=least_square_approximator3(a)[0][0]*x**3+least_square_approximator3(a)[0][1]*x**2+least_square_approximator3(a)[0][2]*x+least_square_approximator3(a)[0][-1]
    plt.plot(x,y)
    plt.title("Third Order Approximation")
    plt.xlabel("Values")
    plt.ylabel("Function y={}t^3+{}t^2+{}^t+{}".format(least_square_approximator3(a)[0][0],least_square_approximator3(a)[0][1],least_square_approximator3(a)[0][2],least_square_approximator3(a)[0][-1]))
    for i in a:
        plt.scatter(i[0],i[1],s=50)
    plt.show()
    print("-"*100)
    x=np.arange(0,0.3,0.1)
    y=[least_square_approximator(a)[-1],least_square_approximator2(a)[-1],least_square_approximator3(a)[-1]]
    plt.plot(x,y)
    plt.scatter(x,y,s=50)
    plt.title("Collapsing error function as order of increase in polynomial")
    plt.xlabel("Values")
    plt.ylabel("Error Function Values ||Ax0-y||^2")
    plt.xlabel("Values")
    plt.ylabel("Error values generated by 1st 2nd and 3rd order Polynomial Approximation".format(least_square_approximator2(a)[0][0],least_square_approximator2(a)[0][1],least_square_approximator2(a)[0][-1]))
    plt.show()
    
    
main()
